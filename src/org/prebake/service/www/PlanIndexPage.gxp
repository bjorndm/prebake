<gxp:template name="org.prebake.service.www.PlanIndexPage"
 xmlns="http://www.w3.org/1999/xhtml"
 xmlns:gxp="http://google.com/2001/gxp">
<gxp:import class="org.prebake.service.plan.PlanGraph"/>
<gxp:import class="org.prebake.service.plan.Product"/>
<gxp:import class="java.util.Map"/>
<gxp:import class="java.util.Set"/>
<gxp:param name="planGraph" type="PlanGraph"/>
<gxp:param name="products" type="Map{String, Product}"/>
<gxp:param name="validProducts" type="Set{String}"/>
<html>
  <head>
    <title>Plans</title>
    <script type="text/javascript" src="../www-files/dracula/raphael-min.js"/>
    <script type="text/javascript" src="../www-files/dracula/graffle.js"/>
    <script type="text/javascript" src="../www-files/dracula/graph.js"/>
    <link rel="stylesheet" type="text/css" href="../www-files/styles.css"/>
  </head>
  <body>
    <h1>Plans
      <div id="navbar"><a href="../index.html">Top</a> &#x2022; Plan</div>
    </h1>
    
    <h2>The Plan Graph</h2>
    <div id="plan-graph-cont"></div>
    <!-- The below was adapted from third_party/dracula/index.html -->
    <script type="text/javascript">
var height = 400;
var width = 800;
/* only do all this when document has finished loading (needed for RaphaelJS */
window.onload = function() {
  <!-- Styles used for different kinds of nodes in the draw function below. -->
  var staleNode = {
    getShape: function (r, x, y) {
      var shape = r.ellipse(x, y, 30, 20);
      shape.attr(  // Dark green border around green
          {fill: '#ccc', stroke: '#666', "fill-opacity": 0, "stroke-width": 2});
      return shape;
    }
  };
  var upToDateNode = {
    getShape: function validNodeShape(r, x, y) {
      var shape = r.ellipse(x, y, 30, 20);
      shape.attr(  // Dark grey border around grey
          {fill: '#afa', stroke: '#484', "fill-opacity": 0, "stroke-width": 2});
      return shape;
    }
  };
  
  function noop() {}

  <!--
      send an XMLHttpRequest to plan.json for graph data and layout the graph
      when it arrives and refetches after 2.5 seconds.
    -->
  var lastJsonDrawn;
  function requestGraph() {
    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
      if (req.readyState === 4) {
        var json = req.responseText;
        req.onreadystatechange = noop;
        setTimeout(requestGraph, 2500 /*ms*/);
        if (req.status === 200) {
          if (lastJsonDrawn !== json) {
            lastJsonDrawn = json;
            drawGraph(JSON.parse(json));
          }
        }
      } 
    };
    req.open('GET', 'plan.json', true);
    req.send();
  }

  function scrollerTo(nodeName) {
    return function () { window.location = '#detail:' + nodeName; };
  }

  <!-- draws a graph given JSON of the form fetchable from plan.json -->
  function drawGraph(graphJson) {
    var g = new Graph();
    for (var nodeName in graphJson.graph) {
      var nodeInfo = graphJson.graph[nodeName]; 
      g.addNode(nodeName, nodeInfo.upToDate ? upToDateNode : staleNode);
    }
    <![CDATA[
    var nodeStyles = { directed: true };
    for (var nodeName in graphJson.graph) {
      var adjacentNodes = graphJson.graph[nodeName].requires;
      for (var i = 0, n = adjacentNodes.length; i < n; ++i) {
        g.addEdge(nodeName, adjacentNodes[i], nodeStyles);
      }
    }
    ]]>

    <!-- layout the graph using the Spring layout implementation -->
    (new Graph.Layout.Spring(g)).layout();

    <!-- draw the graph using the RaphaelJS draw implementation -->
    var planGraphCont = document.getElementById('plan-graph-cont');
    while (planGraphCont.firstChild) {
      planGraphCont.removeChild(planGraphCont.firstChild);
    }
    var planGraphDiv = document.createElement('DIV');
    planGraphCont.appendChild(planGraphDiv);
    planGraphDiv.id = 'plan-graph';
    var renderer = new Graph.Renderer.Raphael('plan-graph', g, width, height);
    renderer.draw();

    for (var nodeName in graphJson.graph) {
      g.nodes[nodeName].shape.click(scrollerTo(nodeName));
    }
  }
  
  requestGraph();
};
    </script>
    <h2>Products</h2>
    <gxp:loop var="product" type="Product" iterable="products.values()">
      <h3><a>
        <gxp:attr name="id">detail:<gxp:eval expr="product.name"/></gxp:attr>
        <gxp:attr name="href">./<gxp:eval expr="product.name"/></gxp:attr>
        <gxp:eval expr="product.name"/>
      </a></h3>
      <gxp:if cond="product.help != null">
        <gxp:if cond="!product.help.isSummaryInferred()">
          <p class="preformat"><gxp:eval expr="product.help.summaryHtml"/></p>
        </gxp:if>
        <div class="preformat"><gxp:eval expr="product.help.detailHtml"/></div>
      </gxp:if>
    </gxp:loop>
  </body>
</html>
</gxp:template>
